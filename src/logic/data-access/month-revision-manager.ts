/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
import _ from "lodash";
import {
  createEmptyMonthDataModel,
  isMonthModelEmpty,
  MonthDataModel,
} from "../../state/schedule-data/schedule-data.model";
import { VerboseDateHelper } from "../../helpers/verbose-date.helper";
import { RevisionKey, RevisionType, ScheduleKey } from "./persistance-store.model";
import { LocalMonthPersistProvider } from "./month-persistance-provider";

export class MonthRevisionManager {
  private localMonthPersistProvider: LocalMonthPersistProvider;

  constructor() {
    this.localMonthPersistProvider = new LocalMonthPersistProvider();
  }

  public async saveMonthRevision(
    revisionType: RevisionType,
    monthDataModel: MonthDataModel
  ): Promise<void> {
    if (isMonthModelEmpty(monthDataModel)) {
      return;
    }

    const oppositeRevisionType = revisionType === "actual" ? "primary" : "actual";

    const oppositeRevision = await this.getMonthRevision(
      monthDataModel.scheduleKey.getRevisionKey(oppositeRevisionType)
    );

    const isMonthInFuture = VerboseDateHelper.isMonthInFuture(
      monthDataModel.scheduleKey.month,
      monthDataModel.scheduleKey.year
    );

    const shouldSaveOppositeRevision =
      _.isNil(oppositeRevision) ||
      oppositeRevision.isAutoGenerated ||
      revisionType === "primary" || // update actual when saving primary
      isMonthInFuture; // primary and actual should be sync in the future

    if (shouldSaveOppositeRevision) {
      await this.localMonthPersistProvider.saveMonth(oppositeRevisionType, monthDataModel);
    }

    await this.localMonthPersistProvider.saveMonth(revisionType, monthDataModel);
  }

  public getMonthRevision(revisionKey: RevisionKey): Promise<MonthDataModel | undefined> {
    return this.localMonthPersistProvider.getMonth(revisionKey);
  }

  async getOrGenerateMonthRevision(
    monthKey: ScheduleKey,
    revision: RevisionType,
    baseMonth: MonthDataModel
  ): Promise<MonthDataModel> {
    let monthDataModel = await this.getMonthRevision(monthKey.getRevisionKey(revision));

    if (_.isNil(monthDataModel)) {
      monthDataModel = await this.generateMonthRevision(monthKey, revision, baseMonth);
    }

    return monthDataModel;
  }

  private async generateMonthRevision(
    monthKey: ScheduleKey,
    revision: RevisionType,
    baseMonth: MonthDataModel
  ): Promise<MonthDataModel> {
    const monthDataModel = createEmptyMonthDataModel(monthKey, baseMonth);
    await this.saveMonthRevision(revision, monthDataModel);
    return monthDataModel;
  }

  async getOrGenerateMonthNeighbours(
    month: MonthDataModel
  ): Promise<[MonthDataModel, MonthDataModel]> {
    const scheduleKey = new ScheduleKey(month.scheduleKey.month, month.scheduleKey.year);

    const { nextMonthKey } = scheduleKey;
    const isNextMonthInFuture = VerboseDateHelper.isMonthInFuture(
      nextMonthKey.month,
      nextMonthKey.year
    );
    const nextMonthRevision = isNextMonthInFuture ? "primary" : "actual";

    return [
      await this.getOrGenerateMonthRevision(scheduleKey.prevMonthKey, "actual", month),
      await this.getOrGenerateMonthRevision(nextMonthKey, nextMonthRevision, month),
    ];
  }
}
